{
  "author": {
    "name": "Matt Walters",
    "email": "mattwalters5@gmail.com"
  },
  "contributors": [
    {
      "name": "mattwalters5@gmail.com"
    },
    {
      "name": "timisbusy@gmail.com"
    },
    {
      "name": "mail@chrisabrams.com"
    }
  ],
  "name": "servicebus",
  "description": "Simple service bus for sending events between processes using amqp.",
  "version": "1.0.11",
  "homepage": "https://github.com/mateodelnorte/servicebus",
  "repository": {
    "type": "git",
    "url": "git://github.com/mateodelnorte/servicebus.git"
  },
  "engines": {
    "node": "0.6 || 0.8 || 0.9 || 0.10"
  },
  "dependencies": {
    "amqplib": "^0.2.0",
    "debug": "^0.7.4",
    "extend": "^1.2.1",
    "node-uuid": "^1.4.0",
    "readable-id": "0.0.2"
  },
  "devDependencies": {
    "longjohn": "~0.2.0",
    "mocha": ">=1.2.1",
    "should": "0.6.3",
    "sinon": "~1.7.3"
  },
  "optionalDependencies": {},
  "readme": "# servicebus\n\n  Simple service bus for sending events between processes using amqp. Allows for send/receive and publish/subscribe pattern messaging over RabbitMQ.  \n\n## Configuration\n\n## Sending and Receiving\n\n  Servicebus allows simple sending and recieving of messages in a 1:1 sender:listener configuration. The following two processes will send an event message called 'my.event' every second from process A to process B via RabbitMQ and print out the sent event:\n\n  Process A:\n    \n    var bus = require('servicebus').bus();\n    bus.listen('my.event', function (event) {\n      console.log(event);\n    });\n\n  Process B:\n    \n    var bus = require('servicebus').bus();\n    \n    setInterval(function () {\n      bus.send('my.event', { my: 'event' });\n    }, 1000);\n  \n## Round-Robin Load Distribution\n\n  Simply running multiple versions of Process A, above, will cause servicebus to distribute sent messages evenly accross the list of listeners, in a round-robin pattern. \n\n## Message Acknowledgement\n\n  (Note: message acking requires use of the retry() middleware, referenced below)\n\n  Servicebus integrates with RabbitMQ's message acknowledement functionality, which causes messages to queue instead of sending until the listening processes marks any previously received message as acknowledged or rejected. Messages can be acknowledged or rejected with the following syntax. To use ack and reject, it must be specified when defining the listening function: \n\n    bus.listen('my.event', { ack: true }, function (event) {\n      event.handle.acknowledge(); // acknowledge a message\n      event.handle.ack(); // short hand is also available\n      event.handle.reject(); // reject a message\n    });\n\n  Message acknowledgement is suited for use in load distribution scenarios. \n\n# Publish / Subscribe\n\n  Servicebus can also send messages from 1:N processes in a fan-out architecture. In this pattern, one sender publishes a message and any number of subscribers can receive. The pattern for usage looks very similar to send/listen:\n\n  Process A (can be run any number of times, all will receive the event):\n    \n    var bus = require('servicebus').bus();\n    bus.subscribe('my.event', function (event) {\n      console.log(event);\n    });\n\n  Process B:\n    \n    var bus = require('servicebus').bus();\n    \n    setInterval(function () {\n      bus.publish('my.event', { my: 'event' });\n    }, 1000);\n    \n# Topic Routing\n\n  To use topic routing to accept multiple events in a single handler, use publish and subscribe and the following syntax:\n  \n  ```\n  bus.publish('event.one', { event: 'one' });\n  bus.publish('event.two', { event: 'two' });\n  ```\n  and for the listener...\n  ```\n  bus.subscribe('event.*', function (msg) ...\n  ```\n\n# Middleware\n\nServicebus allows for middleware packages to enact behavior at the time a message is sent or received. They are very similar to connect middleware in their usage: \n\n```\n  if ( ! process.env.RABBITMQ_URL)\n    throw new Error('Tests require a RABBITMQ_URL environment variable to be set, pointing to the RabbiqMQ instance you wish to use.');\n\n  var busUrl = process.env.RABBITMQ_URL\n\n  var bus = require('../').bus({ url: busUrl });\n\n  bus.use(bus.package());\n  bus.use(bus.correlate());\n  bus.use(bus.log());\n  bus.use(bus.retry());\n\n  module.exports.bus = bus;\n```\n\n Middleware may defined one or two functions to modify incoming or outgoing messages:\n\n```\n...\n\n  function logIncoming (queueName, message, next) {\n    log('received ' + util.inspect(message));\n    next(null, queueName, message);\n  }\n\n  function logOutgoing (message, headers, deliveryInfo, messageHandle, options, next) {    \n    log('sending ' + util.inspect(message));\n    next(null, message, headers, deliveryInfo, messageHandle, options);\n  }\n\n  return {\n    handleIncoming: logIncoming,\n    handleOutgoing: logOutgoing\n  };\n```\n\nhandleIncoming pipelines behavior to be enacted on an incoming message. handleOutgoing pipelines behavior to be enacted on an outgoing message. To say that the behavior is pipelined is to say that each middleware is called in succession, allowing each to enact its behavior before the next. (in from protocol->servicebus->middleware 1->middleware 2->servicebus->user code)\n\n## Included Middleware\n\n### Correlate\n\nCorrelate simply adds a .cid (Correlation Identity) property to any outgoing message that doesn't already have one. This is useful for following messages in logs across services.\n\n### Logger\n\nLogger ensures that incoming and outgoing messages are logged to stdout via the debug module. (Use this in non-high throughput scenarios, otherwise you'll have some very quickly growing logs)\n\n### Package\n\nPackage repackages outgoing messages, encapsulating the original message as a .data property and adding additional properties for information like message type and datetime sent: \n\n```\n  // bus.publish('my:event', { my: 'event' });\n  {\n    my: 'event'\n  };\n```\nbecomes\n```\n  {\n    data: {\n      my: 'event'\n    }\n    , datetime: 'Wed, 04 Sep 2013 19:31:11 GMT'\n    , type: 'my:event'\n  };\n```\n\n### Retry\n\nRetry provides ability to specify a max number of times an erroring message will be retried before being placed on an error queue. The retry middleware requires the correlate middleware. \n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mateodelnorte/servicebus/issues"
  },
  "_id": "servicebus@1.0.11",
  "_shasum": "1a9bd0ba12a8699a11ba6ff5c84004934868a7a3",
  "_from": "servicebus@",
  "_resolved": "https://registry.npmjs.org/servicebus/-/servicebus-1.0.11.tgz"
}
